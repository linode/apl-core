name: Build and publish Docker
on:
  push:
    branches:
      - '**'
    tags-ignore:
      - '*'
env:
  CACHE_REGISTRY: ghcr.io
  CACHE_REPO: redkubes/otomi-core
  REPO: otomi/core
  GIT_USER: redkubesbot
  GIT_PASSWORD: ${{ secrets.GIT_PASSWORD }}
  DOCKER_PASSWORD: ${{ secrets.DOCKERHUB_OTOMI_TOKEN }}

jobs:
  build-test-push:
    if: (!github.event.act && !contains(github.event.head_commit.message, 'chore(release)') && !contains(github.event.head_commit.message, 'ci skip') && !startsWith(github.ref, 'refs/tags/'))
    runs-on: ubuntu-latest
    env:
      COMMIT_MSG: ${{ github.event.head_commit.message }}
    steps:
      - name: Set env
        run: |
          tag=${GITHUB_REF##*/}
          echo "Creating tag: $tag"
          echo "TAG=$tag" >> $GITHUB_ENV
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
      - name: Checkout
        uses: actions/checkout@v2
        with:
          token: ${{ env.GIT_PASSWORD }}
          fetch-depth: 2
      - name: CI tests, image build and push tag for master or branch
        uses: whoan/docker-build-with-cache-action@v5
        with:
          username: redkubesbot
          password: '${{ secrets.NPM_TOKEN }}'
          registry: ${{ env.CACHE_REGISTRY }}
          image_name: ${{ env.CACHE_REPO }}
          image_tag: ${{ env.TAG }}
          pull_image_and_stages: false

  integration:
    needs: build-test-push
    # skip integration check for releases, as the master they are derived from have already been integration tested:
    if: ((github.event.act || contains(github.event.head_commit.message, '[kind]') || github.ref == 'refs/heads/master') && !contains(github.event.head_commit.message, 'chore(release)'))
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Set globalPullSecret if not running locally
        if: (!github.event.act)
        run: |
          cmd="docker run --rm -v $PWD/tests/kind/env/settings.yaml:$PWD/settings.yaml mikefarah/yq:3.3.4 yq w -i $PWD/settings.yaml"
          $cmd otomi.globalPullSecret.password $DOCKER_PASSWORD
          $cmd otomi.globalPullSecret.username otomi
      - name: Pull the image that was built for this branch
        run: |
          TAG=${GITHUB_REF##*/}
          docker pull $CACHE_REGISTRY/$CACHE_REPO:$TAG
          # tag the cached image as if it was already published in docker hub:
          docker tag $CACHE_REGISTRY/$CACHE_REPO:$TAG $REPO:$TAG
      - name: Execute otomi validate-values on the kind test folder
        run: |
          docker run --rm -e CI=1 -v $PWD/tests/kind:/home/app/stack/env otomi/core:${GITHUB_REF##*/} validate-values
      - name: Run kind
        env:
          KIND_CA_CERT: ${{ secrets.KIND_CA_CERT }}
          KIND_CA_KEY: ${{ secrets.KIND_CA_KEY }}
        run: |
          docker network inspect kind >/dev/null 2>&1 || docker network create --driver bridge kind && docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --network kind otomi/kind:latest
          docker cp kind-control-plane:/etc/kubernetes/admin.conf $PWD/kind/kubeconfig
          chmod +r ./kind/kubeconfig
          docker run --rm -v $PWD/kind/kubeconfig:/home/app/.kube/config -e CI=1 -e KIND_CA_KEY="$KIND_CA_KEY" -e KIND_CA_CERT="$KIND_CA_CERT" --network kind -v $PWD/tests/kind:/home/app/stack/env otomi/core:${GITHUB_REF##*/} apply

  release:
    needs: integration
    if: (!github.event.act && contains(github.event.head_commit.message, 'chore(release)') && github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    env:
      COMMIT_MSG: ${{ github.event.head_commit.message }}
    steps:
      - name: Set env
        run: |
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
      - name: Create and push git tag
        id: git_tag
        run: |
          docker login -u otomi -p $DOCKER_PASSWORD
          TAG=${GITHUB_REF##*/}
          # get image from cache and retag
          docker pull $CACHE_REGISTRY/$CACHE_REPO:$TAG
          docker tag $CACHE_REGISTRY/$CACHE_REPO:$TAG $REPO:$TAG
          docker tag $REPO:$TAG $REPO:latest
          docker push $REPO:latest
          release_tag=v${COMMIT_MSG#* }
          echo ::set-output name=tag::$release_tag
          echo "Releasing $REPO:$release_tag"
          docker tag $REPO:$TAG $REPO:$release_tag
          docker push $REPO:$release_tag
          echo "machine github.com login $GIT_USER password $GIT_PASSWORD" > ~/.netrc
          git tag -am "$COMMIT_MSG" $release_tag && git push --follow-tags origin master
          changelog=$(cat CHANGELOG.md | awk -v n=2 '/### \[[0-9]*/&&!--n{exit}{print}')
          # now do some escaping because github does not help us here:
          changelog="${changelog//'%'/'%25'}"
          changelog="${changelog//$'\n'/'%0A'}"
          changelog="${changelog//$'\r'/'%0D'}"
          echo ::set-output name=changes::$changelog
      - name: Create GitHub release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.git_tag.outputs.tag }}
          release_name: Release ${{ steps.git_tag.outputs.tag }}
          body: ${{ steps.git_tag.outputs.changes }}

  chart-release:
    if: (!github.event.act && github.ref == 'refs/heads/master')
    needs: release
    runs-on: ubuntu-latest
    container:
      image: otomi/tools:v1.4.20
      options: --user 0
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Check for changes
        id: prereq
        run: |
          # Release new chart only if its version changes
          helm repo add otomi https://otomi.io/otomi-core
          helm repo update
          this_version=$(cat chart/otomi/Chart.yaml | yq r - 'version')
          chart_version=$(helm search repo otomi -o json | jq -r 'sort_by(.version) | .[-1].version')
          new_patch_version=$((${chart_version##*.}+1)) 
          [ "$this_version" = "$chart_version" ] && echo "The current version ($this_version) is the same as the last released version ($chart_version). Skipping chart release." && exit
          echo ::set-output name=has_changes::true
          release_tag=v$(cat package.json | jq -r '.version')
          sed --in-place "s/APP_VERSION_PLACEHOLDER/$release_tag/g" chart/otomi/Chart.yaml
          sed --in-place "s/CHART_PATCH_PLACEHOLDER/$new_patch_version/g" chart/otomi/Chart.yaml
          sed --in-place "s/APP_VERSION_PLACEHOLDER/$release_tag/g" chart/otomi/values.yaml
          # copy readme from repo into the charts and add tpl/chart-values.md
          cp README.md chart/otomi/
          printf "\n\n" >>chart/otomi/README.md
          cat tpl/chart-values.md >>chart/otomi/README.md
          # generate schema
          npx js-yaml values-schema.yaml > chart/otomi/values.schema.json
          # and set the global id for git as it seems needed by the next step when a custom image is used
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
      - if: '${{ steps.prereq.outputs.has_changes }}'
        name: Create and publish otomi chart release
        id: chart_release
        uses: helm/chart-releaser-action@v1.2.1
        with:
          charts_dir: chart
          charts_repo_url: https://otomi.io/charts/
        env:
          CR_TOKEN: '${{ secrets.GITHUB_TOKEN }}'

  notification:
    runs-on: ubuntu-latest
    needs: [build-test-push, integration, release, chart-release]
    if: always()
    steps:
      - name: Slack Notification
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: github-ci
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/redkubes.png?size=48
          SLACK_TITLE: CI run
          SLACK_USERNAME: RedKubesBot
