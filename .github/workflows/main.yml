name: Build and publish Docker
on:
  push:
    branches:
      - '**'
    tags-ignore:
      - '*'
env:
  CACHE_REGISTRY: ghcr.io
  CACHE_REPO: redkubes/otomi-core
  REPO: otomi/core
  GIT_USER: redkubesbot

jobs:
  build-test-cache:
    if: (!contains(github.event.head_commit.message, 'ci skip') && !startsWith(github.ref, 'refs/tags/') && !github.event.act)
    runs-on: ubuntu-latest
    env:
      COMMIT_MSG: ${{ github.event.head_commit.message }}
    steps:
      - name: Set env
        run: |
          tag=${GITHUB_REF##*/}
          echo "Creating tag: $tag"
          echo "TAG=$tag" >> $GITHUB_ENV
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl apache2-utils apt-transport-https awscli gettext git gnupg gnupg2 groff locales nano netcat openssh-server python3 python3-pip python3-setuptools rlwrap vim rsync
          sudo locale-gen en_US.UTF-8

      - name: Install kubectl
        run: |
          KUBECTL_VERSION="1.26.9"
          curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl.sha256"
          echo "$(cat kubectl.sha256) kubectl" | sha256sum --check
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Install helm
        run: |
          HELM_VERSION="3.12.3"
          wget https://get.helm.sh/helm-v${HELM_VERSION}-linux-amd64.tar.gz
          tar -zxvf helm-v${HELM_VERSION}-linux-amd64.tar.gz
          sudo mv linux-amd64/helm /usr/local/bin/helm

      - name: Install helm plugins
        run: |
          helm plugin install https://github.com/databus23/helm-diff --version 3.8.0
          helm plugin install https://github.com/jkroepke/helm-secrets --version 3.15.0

      - name: Install SOPS
        run: |
          SOPS_VERSION="3.7.3"
          curl -L -o sops https://github.com/mozilla/sops/releases/download/v${SOPS_VERSION}/sops-v${SOPS_VERSION}.linux
          chmod +x sops
          sudo mv sops /usr/local/bin/

      - name: Install jq
        run: |
          JQ_VERSION="1.6"
          curl -L -o jq https://github.com/stedolan/jq/releases/download/jq-${JQ_VERSION}/jq-linux64
          chmod +x jq
          sudo mv jq /usr/local/bin/

      - name: Install yq
        run: |
          YQ_VERSION="v4.42.1"
          wget https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64 -O yq
          chmod +x yq
          sudo mv yq /usr/local/bin/

      - name: Install kubeconform
        run: |
          KUBECONFORM_VERSION="v0.6.4"
          curl -L -o kubeconform.tar.gz https://github.com/yannh/kubeconform/releases/download/${KUBECONFORM_VERSION}/kubeconform-linux-amd64.tar.gz
          tar -xzf kubeconform.tar.gz
          chmod +x kubeconform
          sudo mv kubeconform /usr/local/bin/

      - name: Install gucci
        run: |
          GUCCI_VERSION="1.6.6"
          curl -L -o gucci https://github.com/noqcks/gucci/releases/download/${GUCCI_VERSION}/gucci-v${GUCCI_VERSION}-linux-amd64
          chmod +x gucci
          sudo mv gucci /usr/local/bin/

      - name: Install helmfile
        run: |
          HELMFILE_VERSION="0.156.0"
          curl -L -o helmfile.tar.gz "https://github.com/helmfile/helmfile/releases/download/v${HELMFILE_VERSION}/helmfile_${HELMFILE_VERSION}_linux_amd64.tar.gz"
          tar -xzf helmfile.tar.gz
          chmod +x helmfile
          sudo mv helmfile /usr/local/bin/

      - name: Install Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'

      - name: Install additional Node packages
        run: |
          sudo npm install -g ajv-cli@v3.3.0 json-dereference-cli@0.1.2 zx
      - name: Checkout
        uses: actions/checkout@v4
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE }}
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Github Packages
        uses: docker/login-action@v3
        with:
          username: otomi
          password: ${{ secrets.DOCKERHUB_OTOMI_TOKEN }}
      - name: CI Test
        run: |
          export NODE_ENV='test'
          export CI=true
          export ENV_DIR=$PWD
          export IN_DOCKER='1'
          export VERBOSITY='2'
          export DISABLE_SYNC='1'
          export NODE_PATH='dist'
          npm config set update-notifier false
          npm ci --ignore-scripts && npm run compile
          ln -s ./tests/fixtures env && npm test
          npm prune --production

      - name: image build and push tag for branch
        uses: docker/build-push-action@v5
        with:
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.REPO }}:${{ env.TAG }}

  release:
    needs: build-test-cache
    if: always() && (startsWith(github.ref, 'refs/heads/releases/') || startsWith(github.ref, 'refs/heads/main')) && startsWith(github.event.head_commit.message, 'chore(release)') && !github.event.act
    runs-on: ubuntu-latest
    env:
      COMMIT_MSG: ${{ github.event.head_commit.message }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set env
        run: |
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
      - name: Create and push git tag
        id: git_tag
        run: |
          TAG=${GITHUB_REF##*/}
          docker login -u otomi -p ${{ secrets.DOCKERHUB_OTOMI_TOKEN }}
          docker pull $REPO:$TAG
          docker tag $REPO:$TAG $REPO:latest
          docker push $REPO:latest
          release_tag="v$(echo $COMMIT_MSG | cut -d' ' -f2)"
          echo tag=$release_tag >> $GITHUB_OUTPUT
          echo "Releasing $REPO:$release_tag"
          docker tag $REPO:$TAG $REPO:$release_tag
          docker push $REPO:$release_tag
          docker login -u $GIT_USER -p '${{ secrets.NPM_TOKEN }}' ghcr.io
          docker tag $REPO:$TAG $CACHE_REGISTRY/$CACHE_REPO:$release_tag
          docker push $CACHE_REGISTRY/$CACHE_REPO:$release_tag
          echo "machine github.com login $GIT_USER password ${{ secrets.GIT_PASSWORD }}" > ~/.netrc
          git tag -am "$COMMIT_MSG" $release_tag && git push --follow-tags
          #Cut the CHANGELOG.md file up to the first occurence of the "### \[[0-9]*" (meaning three #, a space,a square bracket and any number after it)
          sed -n '/### \[[0-9]*/q;p' CHANGELOG.md > NEW_CHANGELOG.md
      - name: Create GitHub release
        uses: ncipollo/release-action@v1.12.0
        env:
          token: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag: ${{ steps.git_tag.outputs.tag }}
          name: Release ${{ steps.git_tag.outputs.tag }}
          bodyFile: 'NEW_CHANGELOG.md'
          generateReleaseNotes: true
  chart-release:
    needs: release
    if: always() && contains(needs.release.result, 'success') && !github.event.act
    runs-on: ubuntu-latest
    container:
      image: otomi/tools:v1.4.20
      options: --user 0
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Prepare chart
        id: prepare_chart
        run: |
          # Install and update helm repo
          helm repo add otomi https://otomi.io/otomi-core
          helm repo update

          # Retrieve the app version from package.json
          app_version=$(jq -r '.version' package.json)
          if [ -z "$app_version" ]; then
              echo "Error: Could not retrieve app version from package.json"
              exit 1
          fi

          # Extract major and minor from the app version
          new_app_major=$(echo "$app_version" | cut -d '.' -f 1)
          new_app_minor=$(echo "$app_version" | cut -d '.' -f 2)

          # Get existing helm charts in the registry
          helm_output=$(helm search repo otomi -l -o json)

          # Use jq to parse the output and find the latest version for the given $new_app_major.$new_app_minor app version
          existing_version=$(echo "$helm_output" | jq -r --arg major "$new_app_major" --arg minor "$new_app_minor" '
            map(select(.app_version | startswith("v\($major).\($minor)"))) |
            max_by(.version | split(".") | map(tonumber)) |
            .version'
          )

          # Update Chart.yaml and values.yaml with the new app version
          sed -i "s/0.0.0-chart-version/$app_version/g" chart/otomi/Chart.yaml
          sed -i "s/APP_VERSION_PLACEHOLDER/v$app_version/g" chart/otomi/Chart.yaml

          echo "Chart and values files updated successfully with version $app_version"

          # Copy readme from repo into the charts and add tpl/chart-values.md
          cp README.md chart/otomi/
          printf "\n\n" >>chart/otomi/README.md
          cat tpl/chart-values.md >>chart/otomi/README.md

          # Generate schema
          npx js-yaml values-schema.yaml > chart/otomi/values.schema.json

          # Set the global id for git as it seems needed by the next step when a custom image is used
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
      - name: Create and publish otomi chart release
        id: chart_release
        uses: helm/chart-releaser-action@v1.6.0
        with:
          charts_dir: chart
          skip_existing: true
          mark_as_latest: false
        env:
          CR_TOKEN: '${{ secrets.GITHUB_TOKEN }}'

  test-otomi-release:
    name: Test Helm Chart Installation
    needs: [release, chart-release]
    runs-on: ubuntu-latest
    steps:
      - name: Use Scaleway CLI
        uses: scaleway/action-scw@v0
        with:
          save-config: true
          export-config: true
          version: v2.26.0
          access-key: ${{ secrets.SCW_ACCESS_KEY }}
          secret-key: ${{ secrets.SCW_SECRET_KEY }}
          default-project-id: ${{ secrets.SCW_DEFAULT_PROJECT_ID }}
          default-organization-id: ${{ secrets.SCW_DEFAULT_ORGANIZATION_ID }}
      - name: Pulling the helm chart
        run: |
          # Install and update helm repo
          helm repo add otomi https://otomi.io/otomi-core
          helm repo update

          # Get latest version of otomi
          latest_version=$(helm search repo otomi -l | grep -m 1 otomi | awk '{print $2}')
          echo The latest version to be tested is: $latest_version
      - name: Creating the cluster
        run: |
          # Create cluster private network and get ID
          SCALEWAY_PRIVATE_NETWORK_ID=$(scw vpc private-network create project-id=${{ secrets.SCW_DEFAULT_PROJECT_ID }} name='otomi-test-release' region=nl-ams -ojson | jq -r .id)

          # Get k8s 1.27 patch version
          K8s_VERSION=$(scw k8s version list -o json | jq -ce '.[] | .name' -r | grep 1.27)

          # Create cluster
          scw k8s cluster create \
            name=otomi-test-release \
            pools.0.node-type=PRO2-M \
            private-network-id=$SCALEWAY_PRIVATE_NETWORK_ID \
            auto-upgrade.enable=false \
            cni=calico \
            pools.0.name=otomi-test-release \
            pools.0.size=3 \
            pools.0.max-size=3 \
            pools.0.autohealing=true \
            pools.0.autoscaling=true \
            pools.0.root-volume-size=50GB \
            version=$K8s_VERSION \
            region=nl-ams \
            project-id=${{ secrets.SCW_DEFAULT_PROJECT_ID }} \
            --wait
          echo "Cluster deployed successfully"
      - name: Installing new otomi release
        run: |
          # Get cluster ID and set env var
          cluster_id=$(scw k8s cluster list region=nl-ams -o json | jq -r '.[] | select(.name == "otomi-test-release") | .id')
          echo "Cluster ID: $cluster_id"
          echo SCALEWAY_CLUSTER_ID=$cluster_id >> $GITHUB_ENV

          # Get kubeconfig
          scw k8s kubeconfig install $cluster_id region=nl-ams
          echo "Kubeconfig installed successfully"

          # Update values.yaml integration test file
          SCALEWAY_CLUSTER_CONTEXT=`kubectl config current-context`

          # Install otomi
          helm install otomi otomi/otomi \
          --wait --wait-for-jobs --timeout 30m0s \
          --set cluster.provider=scaleway \
          --set cluster.name=otomi-test-release \
          --set cluster.k8sContext=$SCALEWAY_CLUSTER_CONTEXT
      - name: Gather k8s events on failure
        if: failure()
        run: |
          kubectl get events --sort-by='.lastTimestamp' -A
      - name: Gather k8s pods on failure
        if: failure()
        run: |
          kubectl get pods -A -o wide
      - name: Gather otomi logs on failure
        if: failure()
        run: |
          kubectl logs jobs/otomi --tail 150
      - name: Delete k8s cluster at Scaleway
        if: always()
        run: |
          scw k8s cluster delete ${{ env.SCALEWAY_CLUSTER_ID }} with-additional-resources=true region=nl-ams

  notification:
    needs: [build-test-cache, release, chart-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Slack Notification
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: github-ci
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/redkubes.png?size=48
          SLACK_TITLE: CI run
          SLACK_USERNAME: RedKubesBot
