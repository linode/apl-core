apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  creationTimestamp: null
  name: pspallowedusers
spec:
  crd:
    spec:
      names:
        kind: PspAllowedUsers
  targets:
  - libs:
    - |-
      package lib.core

      default is_gatekeeper = false

      is_gatekeeper {
        has_field(input, "review")
        has_field(input.review, "object")
      }

      resource = input.review.object {
        is_gatekeeper
      }

      resource = input {
        not is_gatekeeper
      }

      review = input.review {
        is_gatekeeper
      }

      review = {"object": resource, "kind": {"group": group, "kind": kind, "version": version}} {
        not is_gatekeeper
      }

      parameters = input.parameters {
        trace(sprintf("has input.parameters: %v", [input.parameters]))
        is_gatekeeper
      }

      format(msg) = {"msg": msg}

      format_with_id(msg, id) = msg_fmt {
        msg_fmt := {
          "msg": sprintf("%s: %s", [id, msg]),
          "details": {"policyID": id},
        }
      }

      apiVersion := resource.apiVersion

      name := resource.metadata.name

      gv := split(apiVersion, "/")

      group = gv[0] {
        contains(apiVersion, "/")
      }

      group = "core" {
        not contains(apiVersion, "/")
      }

      version := gv[minus(count(gv), 1)]

      kind := resource.kind

      labels := resource.metadata.labels

      annotations := resource.metadata.annotations

      has_field(obj, field) {
        not object.get(obj, field, "N_DEFINED") == "N_DEFINED"
      }

      missing_field(obj, field) {
        obj[field] == ""
      }

      missing_field(obj, field) {
        not has_field(obj, field)
      }
    - |-
      package lib.exceptions


      import data.lib.annotations
      import data.lib.core
      import data.lib.parameters

      get_safe_annotation[return] {
        all_annotations := annotations.merge_annotations()
        trace(sprintf("all_annotations: %v", [all_annotations]))
        policy_list := sprintf("%s,%s", [
          object.get(all_annotations, annotations.ignoreAnnotationField, ""),
        ])

        trace(sprintf("pod ignore list: %v", [policy_list]))
        return := split(policy_list, ",")
      }

      is_exception(policyID) {
        get_safe_annotation[ignore_list]
        ignore_list[_] == policyID
      }

      is_container_exception(cname, policyID) {
        all_annotations := annotations.merge_annotations()
        policy_list := object.get(all_annotations, annotations.get_container_ignore_field(cname), "")
        trace(sprintf("container ignore list: %v", [policy_list]))
        ignore_list := split(policy_list, ",")
        ignore_list[_] == policyID
      }

      is_exception(policyID) {
        not parameters.policy_parameters(policyID).enabled
      }
    - |-
      package lib.annotations


      import data.lib.core
      import data.lib.pods

      default ignoreAnnotationField = "policy.otomi.io/ignore"

      default paramsAnnotationField = "policy.otomi.io/parameters"

      default containerIgnoreAnnotationField = "policy.otomi.io/ignore.%s"

      default containerParamAnnotationField = "policy.otomi.io/parameters.%s.%s"

      get_container_params_field(cname, policyID) = return {
        return := sprintf(containerParamAnnotationField, [cname, policyID])
      }

      get_container_ignore_field(cname) = return {
        return := sprintf(containerIgnoreAnnotationField, [cname])
      }

      get_default(object, field, _default) = output {
        core.has_field(object, field)
        object[field] != null
        output := object[field]
      }

      get_default(object, field, _default) = output {
        core.has_field(object, field) == false
        output := _default
      }

      merge_annotations = return {
        return := object.union(get_default(core.resource.metadata, "annotations", {}), get_default(pods.pod.metadata, "annotations", {}))
      } else = return {
        return := get_default(pods.pod.metadata, "annotations", {})
        return != null
      } else = return {
        return := get_default(core.resource.metadata, "annotations", {})
        return != null
      } else = return {
        return := {}
      }
    - |-
      package lib.pods

      import data.lib.core

      default pod = false

      pod = core.resource.spec.template {
        pod_templates := ["daemonset", "deployment", "job", "pod", "replicaset", "replicationcontroller", "statefulset"]
        lower(core.kind) == pod_templates[_]
      }

      pod = core.resource.spec.template {
        lower(core.apiVersion) == "serving.knative.dev/v1"
        lower(core.kind) == "service"
      }

      pod = core.resource {
        lower(core.kind) == "pod"
      }

      pod = core.resource.spec.jobTemplate.spec.template {
        lower(core.kind) == "cronjob"
      }

      containers[container] {
        keys := {"containers", "initContainers"}
        all_containers := [c | keys[k]; c := pod.spec[k][_]]
        container := all_containers[_]
      }

      volumes[volume] {
        volume := pod.spec.volumes[_]
      }
    - |-
      package lib.parameters


      import data.lib.annotations
      import data.lib.core

      policy_parameters(policyID) = params {
        trace(sprintf("core_params: %v", [{c | c = core.parameters}]))
        core_params := {c | c = core.parameters[policyID]}

        # trace(sprintf("core_params[policyID]: %v", [core_params]))
        extra_params := {e | e = extra_parameters(policyID)}

        # trace(sprintf("extra_params: %v", [extra_params]))
        params := object.union(core.parameters[policyID], extra_parameters(policyID))
        # trace(sprintf("policy_parameters: %v", [params]))
      }

      extra_parameters(policyID) = params {
        all_annotations := annotations.merge_annotations()
        policyAnnotationField := sprintf("%s.%s", [annotations.paramsAnnotationField, policyID])
        core.has_field(all_annotations, policyAnnotationField)
        params := json.unmarshal(all_annotations[policyAnnotationField])
        trace(sprintf("extra_parameters: %v", [params]))
      } else = params {
        params := {}
      }
    rego: |-
      package pspallowedusers

      import data.lib.core
      import data.lib.exceptions
      import data.lib.parameters
      import data.lib.pods

      policyID = "psp-allowed-users"

      violation[{"msg": msg}] {
        not exceptions.is_exception(policyID)
        fields := ["runAsUser", "runAsGroup", "supplementalGroups", "fsGroup"]
        field := fields[_]
        pods.containers[container]
        not exceptions.is_container_exception(container.name, policyID)
        msg := get_type_violation(field, container)
      }

      get_type_violation(field, container) = msg {
        field == "runAsUser"
        params := parameters.policy_parameters(policyID)
        msg := get_user_violation(params[field], container)
      }

      get_type_violation(field, container) = msg {
        field != "runAsUser"
        params := parameters.policy_parameters(policyID)
        msg := get_violation(field, params[field], container)
      }

      get_user_violation(params, container) = msg {
        rule := params.rule
        provided_user := get_field_value("runAsUser", container, pods.pod)
        not accept_users(rule, provided_user)
        msg := sprintf("Policy: %s - Container %v is attempting to run as disallowed user %v. Allowed runAsUser: %v", [policyID, container.name, provided_user, params])
      }

      get_user_violation(params, container) = msg {
        not get_field_value("runAsUser", container, pods.pod)
        params.rule = "MustRunAs"
        msg := sprintf("Policy: %s - Container %v is attempting to run without a required securityContext/runAsUser", [policyID, container.name])
      }

      get_user_violation(params, container) = msg {
        params.rule = "MustRunAsNonRoot"
        not get_field_value("runAsUser", container, pods.pod)
        not get_field_value("runAsNonRoot", container, pods.pod)
        msg := sprintf("Policy: %s - Container %v is attempting to run without a required securityContext/runAsNonRoot or securityContext/runAsUser != 0", [policyID, container.name])
      }

      accept_users("RunAsAny", provided_user) = true

      accept_users("MustRunAsNonRoot", provided_user) = res {
        res := provided_user != 0
      }

      accept_users("MustRunAs", provided_user) = res {
        ranges := parameters.policy_parameters(policyID).runAsUser.ranges
        res := is_in_range(provided_user, ranges)
      }

      get_violation(field, params, container) = msg {
        rule := params.rule
        provided_value := get_field_value(field, container, pods.pod)
        not is_array(provided_value)
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Policy: %s - Container %v is attempting to run as disallowed group %v. Allowed %v: %v", [policyID, container.name, provided_value, field, params])
      }

      get_violation(field, params, container) = msg {
        rule := params.rule
        array_value := get_field_value(field, container, pods.pod)
        is_array(array_value)
        provided_value := array_value[_]
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Policy: %s - Container %v is attempting to run with disallowed supplementalGroups %v. Allowed %v: %v", [policyID, container.name, array_value, field, params])
      }

      get_violation(field, params, container) = msg {
        not get_field_value(field, container, pods.pod)
        params.rule == "MustRunAs"
        msg := sprintf("Policy: %s - Container %v is attempting to run without a required securityContext/%v. Allowed %v: %v", [policyID, container.name, field, field, params])
      }

      accept_value("RunAsAny", provided_value, ranges) = true

      accept_value("MayRunAs", provided_value, ranges) = res {
        res := is_in_range(provided_value, ranges)
      }

      accept_value("MustRunAs", provided_value, ranges) = res {
        res := is_in_range(provided_value, ranges)
      }

      get_field_value(field, container, obj) = out {
        container_value := get_seccontext_field(field, container)
        out := container_value
      }

      get_field_value(field, container, obj) = out {
        not has_seccontext_field(field, container)
        pod_value := get_seccontext_field(field, obj.spec)
        out := pod_value
      }

      is_in_range(val, ranges) = res {
        matching := {1 | val >= ranges[j].min; val <= ranges[j].max}
        res := count(matching) > 0
      }

      has_seccontext_field(field, obj) {
        get_seccontext_field(field, obj)
      }

      has_seccontext_field(field, obj) {
        get_seccontext_field(field, obj) == false
      }

      get_seccontext_field(field, obj) = out {
        out = obj.securityContext[field]
      }
    target: admission.k8s.gatekeeper.sh
status: {}
