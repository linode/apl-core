#!/usr/bin/env bash
#####################################################################################
##
## NOTE:
## This is a command line tool to operate on otomi-core.
## All commands are executed in docker container.
## Keep this file as simple as possible:
## - do not depend on any external files.
## - do not use any non standard tooling.
## - only Docker is needed to run otomi-core image
## If you need to use any extra binaries then most probably you want to add them to the otomi/tools image.
##
#####################################################################################
set -e

[ "${BASH_VERSINFO:-0}" -lt 4 ] && echo "You are using $BASH_VERSINFO, while we only support Bash -ge than version 4. Please upgrade." && exit 1
[ -n "$DEBUG" ] && unset DEBUG && PS4='$BASH_SOURCE:$LINENO:' bash -x bin/otomi "$@"

command=$1
env_unset='false'
[ "$ENV_DIR" = "" ] && env_unset='true'
ENV_DIR=${ENV_DIR:-$PWD}
[ "$ENV_DIR" = "/home/app/stack" ] && ENV_DIR=$ENV_DIR/env

. bin/common.sh

[ $has_docker = 'false' ] && [ -z "$CI" ] && err "Otomi CLI expects a running docker daemon!" && exit 1

function verbose_env() {
  echo "has_docker=$has_docker"
  echo "ENV_DIR=$ENV_DIR"
  echo "stack_dir=$stack_dir"
  echo "helm_config=$helm_config"
  echo "cmd_image=$cmd_image"
  echo "check_kube_context=$check_kube_context"
  echo "K8S_CONTEXT=$K8S_CONTEXT"
  echo "IN_DOCKER=$IN_DOCKER"
  echo "command=$command"
}

# check_kube_context - a flag to indicate to use kube context and to refresh kube access token before running command in docker
check_kube_context=0
# A path to directory with values directory

mount_stack_dir=0
stack_dir='/home/app/stack'
cmd_image="otomi/core:$(otomi_image_tag)"
docker_terminal_params='-it'
helm_config=''
readme_url='https://github.com/redkubes/otomi-core'
kubeconfig="-v ${KUBECONFIG:-$HOME/.kube/config}:/home/app/.kube/config"

# check if we are in core or values repo (could be improved as it is based on name!)
readonly cwd=$(basename "$PWD")
[ -n "$VERBOSE" ] && echo "CWD: $cwd"
if [ "$cwd" = "otomi-core" ]; then
  [ "$env_unset" = 'true' ] && err "The ENV_DIR environment variable is not set" && exit 1
  [ -n "$VERBOSE" ] && echo "Mounting otomi-core dir"
  stack_dir=$PWD
  mount_stack_dir=1
fi
# now we can retrieve customer name from settings
customer=$(customer_name || $CUSTOMER || "unknown")

# set helm config
helm_config="$HOME/.config/helm"
uname -a | grep -i darwin >/dev/null && helm_config="$HOME/Library/Preferences/helm"

function show_usage() {
  echo "otomi usage:
    bash                run interactive bash shell in otomi-core container
    bats                run BATS on bin/tests (see docs/BATS.md)
    bootstrap           bootstrap values repo with artifacts corresponding to the target cluster's stack version
    check-policies      check if generated manifests adhere to defined OPA policies (takes helmfile options)
    commit              execute wrapper for encrypt -> generate pipelines -> git commit changed files
    configure           Configure otomi settings (stored in $ENV_DIR/otomi.cfg). Currently has only one option: `-c|--cluster` (to set target cluster).
    console             start Otomi Console (add any arg to quit) on http://127.0.0.1:3000 (licensed, so pull secret required for api)
    decrypt             decrypts file(s) given as arguments (relative to env folder), or all env/*.secrets.yaml to env/*.secrets.yaml.dec files
    deploy              execute otomi-core deploy script
    destroy             destroy all or some charts (takes helmfile options)
    diff                diff k8s resources (takes helmfile options)
    encrypt             encrypt file(s) given as arguments (relative to env folder), or all env/*.secrets.yaml files
    help                print this help
    hf                  run helmfile for a set target cluster (takes helmfile options)
    pull                wrapper for git pull && bootstrap
    sync                sync k8s resources (takes helmfile options)
    switch              switch context to the target cluster and bootstraps
    template            export k8s resources (takes helmfile options)
    test                run tests against the target cluster
    values              show helmfile values for target cluster (takes target options)
    validate-templates  validate generated manifests against supported k8s versions/CRDs and best practices (takes helmfile & target options)
    validate-values     validate values for each cluster against JSON schema (takes target options)
    x                   execute command in container

  Env flags:
    CI=1                Exit the script after first error
    DEBUG=1             Run otomi CLI in debug mode
    VERBOSE=1;          Run otomi CLI in verbose mode

  Example helmfile options:
    -l|--label          Select charts by label (format: <label>=<value>), e.g. '-l name=prometheus-operator' or '--label group=jobs'
    -f|--file           Select helmfiles by filename, e.g. '-f helmfile.d/helmfile-15.ingress-core.yaml'
  (For a full list of options please read the helmfile documentation.)

  Target (output) options:
    -A|--all            Target all clusters and charts (not simultaneously with -c|--cluster)     
    -c|--cluster        Override a set target cluster (format: CLOUD-CLUSTER), e.g. '-c aws-dev' or '--cluster azure-demo'
  "
}

function evaluate_k8s_context() {
  local env_path="$ENV_DIR/env/clouds/$CLOUD/$CLUSTER/.env"
  [ ! -f $env_path ] && err "The file '$env_path' does not exist" && exit 1
  . $env_path
  [ -z "$K8S_CONTEXT" ] && err "The K8S_CONTEXT env is not defined in $env_path" && exit 1
  return 0
}

function validate_k8s_context() {
  local context=$(kubectl config current-context)
  if [ "$K8S_CONTEXT" != "$context" ]; then
    read -p "Warning: Your current kubernetes context does not match target context: $K8S_CONTEXT. Would you like to switch kube context to target first? [Y n]" ok
    if [ "${ok:-y}" = "y" ]; then
      kubectl config use $K8S_CONTEXT
      $is_repo && drun bin/bootstrap.sh 1
    else
      exit
    fi
  fi
  return 0
}

function check_sops_file() {
  [ ! -f "$ENV_DIR/.sops.yaml" ] && (
    err "The $ENV_DIR/.sops.yaml does not exist"
    exit 1
  )
  return 0
}

function evaluate_secrets() {
  [ ! -f "$ENV_DIR/.sops.yaml" ] && {
    [ -n "$VERBOSE" ] && echo "Info: The 'secrets.*.yaml files' are not decrypted, because $ENV_DIR/.sops.yaml file is not present"
    return 0
  }
  if [ -z "$CI" ]; then
    local secrets_path="$ENV_DIR/.secrets"
    [ ! -r "$secrets_path" ] && err "Unable to find the '$secrets_path' file.\nPlease follow to documentation: $readme_url" && exit 2
    . $secrets_path
  fi
  prepare_crypt
  return 0
}

function validate_cluster_env() {
  check_kube_context=1
  local err
  [ -z "$CLOUD" ] && err "The CLOUD environment variable is not set" && err=1
  [ -z "$CLUSTER" ] && err "The CLUSTER environment variable is not set" && err=1
  [ -n "$err" ] && exit 2
  return 0
}

function is_repo() {
  [ "$(basename "$PWD")" = "otomi-core" ] && err "Error: Should not be ran from otomi-core" && exit 2
  return 0
}

function run_console() {
  [ -n "$1" ] && docker-compose down --remove-orphans && exit
  # this will create /tmp/otomi-env:
  drun bin/check-console.sh
  # now source the fresh env we created for docker-compose
  . /tmp/otomi-env
  # try to login with the pull secret
  set -o pipefail
  pass=$(echo "$PULL_SECRET" | base64 --decode | jq '.auths["eu.gcr.io"].password|fromjson')
  docker login -u _json_key -p "$pass" "eu.gcr.io"
  echo "Starting Otomi Console at http://127.0.0.1:3000"
  sh -c "sleep 7 && open http://127.0.0.1:3000" &
  docker-compose up
  rm /tmp/otomi-env
}

function drun() {
  local command=$@
  local stack_volume=''
  local socket_volume=''

  [ "${VERBOSE-}" != '' ] && echo "Running in CI: $CI"
  if [ -n "$CI" ]; then
    check_kube_context=0
  # else
  #   socket_volume="-v /var/run/docker.sock:/var/run/docker.sock"
  fi

  # execute any kubectl command to refresh access token
  if [ $check_kube_context -eq 1 ]; then
    evaluate_k8s_context
    validate_k8s_context
    kubectl version >/dev/null
  fi

  if [ $mount_stack_dir -eq 1 ]; then
    stack_volume="-v ${stack_dir}:${stack_dir}"
  fi

  [ -n "$VERBOSE" ] && verbose_env

  # use docker run if has_docker AND either:
  # - not in docker
  # - in docker AND force docker
  if [ "$has_docker" = 'true' ] && [ -z "$IN_DOCKER" ]; then
    [ -n "$VERBOSE" ] && echo "Running dockerized version of command: $command"
    docker run $docker_terminal_params --rm \
      $stack_volume $socket_volume $kubeconfig -v /tmp:/tmp \
      -v $GOOGLE_APPLICATION_CREDENTIALS:$GOOGLE_APPLICATION_CREDENTIALS \
      -v ${HOME}/.ssh:/home/app/.ssh \
      -v ${helm_config}:/home/app/.config/helm \
      -v ${HOME}/.config/gcloud:/home/app/.config/gcloud \
      -v ${HOME}/.aws:/home/app/.aws \
      -v ${HOME}/.azure:/home/app/.azure \
      -v ${ENV_DIR}:${stack_dir}/env \
      -e AZURE_TENANT_ID=$AZURE_TENANT_ID \
      -e AZURE_CLIENT_ID=$AZURE_CLIENT_ID \
      -e AZURE_CLIENT_SECRET=$AZURE_CLIENT_SECRET \
      -e GOOGLE_APPLICATION_CREDENTIALS=$GOOGLE_APPLICATION_CREDENTIALS \
      -e CUSTOMER="$customer" \
      -e VERBOSE="${VERBOSE-}" \
      -e CLOUD="$CLOUD" \
      -e IN_DOCKER='1' \
      -e GCLOUD_SERVICE_KEY="$GCLOUD_SERVICE_KEY" \
      -e CLUSTER="$CLUSTER" \
      -e K8S_CONTEXT="$K8S_CONTEXT" \
      -e DEBUG="$DEBUG" \
      -e CI="$CI" \
      -w $stack_dir \
      $cmd_image \
      $command
  else
    [ -n "$VERBOSE" ] && echo "Running native version of command: $command"
    $command
  fi
}

function execute() {
  shift 2
  case $command in
    apply)
      evaluate_secrets
      validate_cluster_env
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER "$@" apply --skip-deps | grep -Ev $helmfile_output_hide
      ;;
    bash)
      docker_terminal_params='-ti'
      drun bash
      ;;
    bats)
      drun bats -T "$@" bin/tests
      ;;
    bootstrap)
      if [ "$*" != '' ]; then
        validate_cluster_env
      fi
      drun bin/bootstrap.sh 1
      ;;
    check-policies)
      evaluate_secrets
      if [ "$*" != '' ]; then
        validate_cluster_env
      fi
      check_kube_context=0
      drun bin/check-policies.sh "$@"
      ;;
    commit)
      is_repo
      evaluate_secrets
      git -C $ENV_DIR pull
      drun bin/validate-values.sh
      drun bin/pre-commit.sh
      git add . && git commit -m 'Manual commit' --no-verify
      ;;
    console)
      evaluate_secrets
      run_console "$@"
      ;;
    decrypt)
      check_sops_file
      evaluate_secrets
      if [ "$*" != '' ]; then
        for f in "$@"; do
          echo "Decrypting $f"
          drun helm secrets dec ./env/$f >/dev/null
        done
        exit
      else
        drun bin/crypt.sh decrypt
      fi
      ;;
    deploy)
      evaluate_secrets
      validate_cluster_env
      drun bin/deploy.sh | grep -Ev $helmfile_output_hide
      ;;
    diff)
      evaluate_secrets
      validate_cluster_env
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER "$@" diff --skip-deps | grep -Ev $helmfile_output_hide
      ;;
    destroy)
      evaluate_secrets
      validate_cluster_env
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER "$@" destroy | grep -Ev $helmfile_output_hide
      ;;
    encrypt)
      check_sops_file
      evaluate_secrets
      if [ "$*" != '' ]; then
        for f in "$@"; do
          echo "Encrypting $f"
          drun helm secrets enc ./env/$f >/dev/null
        done
        exit
      else
        drun bin/crypt.sh encrypt
      fi
      ;;
    gen-drone)
      evaluate_secrets
      drun bin/gen-drone.sh
      ;;
    hf)
      evaluate_secrets
      validate_cluster_env
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER "$@" | grep -Ev $helmfile_output_hide
      ;;
    pull)
      is_repo
      evaluate_secrets
      git -C $ENV_DIR pull
      drun bin/bootstrap.sh 1
      ;;
    rotate-keys)
      check_sops_file
      evaluate_secrets
      drun bin/crypt.sh rotate
      ;;
    sync)
      evaluate_secrets
      validate_cluster_env
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER "$@" sync --skip-deps | grep -Ev $helmfile_output_hide
      ;;
    template)
      evaluate_secrets
      validate_cluster_env
      check_kube_context=0
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER --quiet "$@" template --skip-deps | grep -Ev $helmfile_output_hide_tpl
      ;;
    test)
      evaluate_secrets
      validate_cluster_env
      drun bin/test.sh
      ;;
    validate-templates)
      evaluate_secrets
      if [ "$*" != '' ]; then
        validate_cluster_env
      fi
      drun bin/validate-templates.sh "$@"
      ;;
    validate-values)
      evaluate_secrets
      drun bin/validate-values.sh "$@"
      ;;
    values)
      evaluate_secrets
      validate_cluster_env
      set -o pipefail
      drun helmfile -e $CLOUD-$CLUSTER -f helmfile.tpl/helmfile-dump.yaml build | grep -Ev $helmfile_output_hide | sed -e $replace_paths_pattern
      ;;
    x)
      check_kube_context=0
      drun "$@"
      ;;
    *)
      show_usage
      [ -z "$1" ] && err "Unknown command: $command" && exit 1
      ;;
  esac
}

[ -z "$command" ] && err "Missing command argument" && show_usage && exit 2

execute $command "$@"
