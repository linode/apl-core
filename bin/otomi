#/usr/bin/env bash
#####################################################################################
##
## NOTE:
## This is a command line tool to operate on otomi-stack.
## All commands are executed in docker container.
## Keep this file as simple as possible:
## - do not depend on any external files.
## - do not use any non standard tooling.
## - only Docker is needed to run otomi-stack image
## If you need to use any extra binaries then most probably you want to add them to the otomi/tools image.
##
#####################################################################################
set -e
command=$1
# VERBOSE - export this varibale to run this script in verbose mode
VERBOSE=${VERBOSE:-0}
# MOUNT_TMP_DIR - export this varaibale to mount yout /tmp directory
MOUNT_TMP_DIR=${MOUNT_TMP_DIR:-0}

# set_kube_context - a flag to indicate to use kube context and to refresh kube access token before running command in docker
set_kube_context=1
# A path to directory with values directory
env_dir=${ENV_DIR:-$PWD}

mount_stack_dir=0
stack_dir='/home/app/stack'
otomi_image=''
docker_terminal_params='-t'
helm_config=''
readme_url='https://github.com/redkubes/otomi-stack'

function set_helm_config() {
  helm_config="$HOME/.config/helm"
  uname -a | grep -i darwin >/dev/null && helm_config="$HOME/Library/Preferences/helm"
  return 0
}

function show_usage() {
  echo "otomi usage:
    apply      apply k8s resources (use labels like '-l name=prometheus-operator')
    aws        run aws cli
    az         run azure cli
    bash       run interactive bash
    bootstrap  bootstrap values repo with artifacts corresponding to the cluster's stack version
    commit     wrapper for encrypt > generate pipelines > git commit changed files
    decrypt    decrypt values to *.secrets.yaml.dec files
    deploy     execute otomi-stack deploy script
    diff       diff k8s resources (use labels like '-l name=prometheus-operator')
    eksctl     run eksctl cli
    encrypt    encrypt values in all *.secrets.yaml files
    gcloud     run gcloud cli
    help       print this help
    hf         run helmfile with CLUSTER and CLOUD already set
    pull       wrapper for git pull > decrypt
    template   export k8s resources (use labels like '-l name=prometheus-operator')
    values     show helmfile values for CLOUD and CLUSTER
    x          execute command in container
  "
}

function evaluate_k8s_context() {
  local env_path="${env_dir}/env/clouds/${CLOUD}/${CLUSTER}/.env"
  [ ! -f $env_path ] && echo "Error: The file '${env_path}' does not exist" && exit 1
  source $env_path
  [[ -z "$K8S_CONTEXT" ]] && echo "Error: The K8S_CONTEXT env is not defined in $env_path" && exit 1
  return 0
}

function validate_k8s_context() {
  local context=$(kubectl config current-context)
  [[ "$K8S_CONTEXT" != "$context" ]] && echo "Error: Your current kubernetes context does not match target context: $K8S_CONTEXT" && exit 1
  return 0
}

function set_env_ini() {
  local init_path=$env_dir/env.ini
  [ ! -f $init_path ] && echo "Error: The file '${init_path}' does not exist" && exit 1
  source $init_path
  local version
  eval "version=\$${CLUSTER}Version"
  [[ -z "$version" ]] && echo "Error: Unable to evaluate '${CLUSTER}Version' variable from $init_path" && exit 1
  [[ -z "$customer" ]] && echo "Error: Unable to evaluate 'customer' variable from $init_path" && exit 1

  otomi_image="eu.gcr.io/otomi-cloud/otomi-stack:${version}"
  return 0
}

evaluate_secrets() {
  local secrets_path="${env_dir}/.secrets"
  [[ ! -r "$secrets_path" ]] && echo "Error: Unable to evaluate the '$secrets_path' file.\nRefer to documentation: $readme_url" && exit 2
  source $secrets_path
  [[ -z "$GCLOUD_SERVICE_KEY" ]] && echo "Error: The GCLOUD_SERVICE_KEY environment variable is not found in .secrets" && exit 2
  return 0
}

validate_cluster_env() {
  [[ -z "$CLOUD" ]] && echo "Error: The CLOUD environment variable is not set" && exit 2
  [[ -z "$CLUSTER" ]] && echo "Error: The CLUSTER environment variable is not set" && exit 2
  return 0
}

is_repo() {
  [[ "$(basename "$PWD")" == 'otomi-stack' ]] && "Error: Should not be ran from otomi-stack" && exit 2
  return 0
}

function drun() {
  local command=$@
  local tmp_volume=''
  local stack_volume=''

  # execute any kubectl command to refresh access token
  if [ $set_kube_context -eq 1 ]; then
    evaluate_k8s_context
    validate_k8s_context
    kubectl version >/dev/null
  fi

  if [ $MOUNT_TMP_DIR -eq 1 ]; then
    tmp_volume=" -v /tmp:/tmp"
  fi

  if [ $mount_stack_dir -eq 1 ]; then
    stack_volume="-v ${stack_dir}:${stack_dir}"
  fi

  if [ $VERBOSE -eq 1 ]; then
    echo "Command: $command"
    verbose_env
  fi

  docker run $docker_terminal_params --rm \
    $tmp_volume \
    -v ${HOME}/.gitconfig:/home/app/.gitconfig \
    -v ${HOME}/.kube/config:/home/app/.kube/config \
    -v ${HOME}/.ssh:/home/app/.ssh \
    -v ${helm_config}:/home/app/.config/helm \
    -v ${HOME}/.config/gcloud:/home/app/.config/gcloud \
    -v ${HOME}/.aws:/home/app/.aws \
    -v ${HOME}/.azure:/home/app/.azure \
    -v ${env_dir}:${stack_dir}/env \
    $stack_volume \
    -e CUSTOMER="$customer" \
    -e CLOUD="$CLOUD" \
    -e GCLOUD_SERVICE_KEY="$GCLOUD_SERVICE_KEY" \
    -e CLUSTER="$CLUSTER" \
    -e K8S_CONTEXT="$K8S_CONTEXT" \
    -w $stack_dir \
    $otomi_image \
    $command
}

function execute() {
  shift 2
  case $command in
  values)
    set_kube_context=0
    validate_cluster_env
    set -o pipefail
    drun helmfile -e ${CLOUD}-$CLUSTER -f helmfile.tpl/helmfile-dump.yaml build | grep -v skipping | grep -v basePath= | sed -e 's@../env@'"${ENV_DIR}"'@g'
    break
    ;;
  hf)
    validate_cluster_env
    set -o pipefail
    drun helmfile -e ${CLOUD}-$CLUSTER $@ | grep -v skipping | grep -v basePath=
    break
    ;;
  aws)
    set_kube_context=0
    drun aws $@
    break
    ;;
  azure)
    set_kube_context=0
    drun aws $@
    break
    ;;
  gcloud)
    set_kube_context=0
    drun aws $@
    break
    ;;
  eksctl)
    set_kube_context=0
    drun aws $@
    break
    ;;
  apply)
    validate_cluster_env
    set -o pipefail
    drun helmfile -e ${CLOUD}-$CLUSTER $@ apply --skip-deps | grep -v skipping | grep -v basePath=
    break
    ;;
  diff)
    validate_cluster_env
    set -o pipefail
    drun helmfile -e ${CLOUD}-$CLUSTER $@ diff --skip-deps | grep -v skipping | grep -v basePath=
    break
    ;;
  sync)
    validate_cluster_env
    set -o pipefail
    drun helmfile -e ${CLOUD}-$CLUSTER $@ sync --skip-deps | grep -v skipping | grep -v basePath=
    break
    ;;
  template)
    set_kube_context=0
    validate_cluster_env
    set -o pipefail
    drun helmfile -e ${CLOUD}-$CLUSTER --quiet $@ template --skip-deps | grep -v skipping | grep -v basePath=
    break
    ;;
  bootstrap)
    set_kube_context=0
    validate_cluster_env
    drun bin/bootstrap.sh $@
    break
    ;;
  deploy)
    validate_cluster_env
    drun bin/deploy.sh | grep -v skipping | grep -v basePath=
    break
    ;;
  encrypt)
    set_kube_context=0
    evaluate_secrets
    drun bin/crypt.sh enc
    break
    ;;
  decrypt)
    set_kube_context=0
    evaluate_secrets
    drun bin/crypt.sh dec
    break
    ;;
  bash)
    set_kube_context=0
    validate_cluster_env
    docker_terminal_params='-it'
    drun bash
    break
    ;;
  kubectl)
    drun kubectl $@
    break
    ;;
  x)
    validate_cluster_env
    set_kube_context=0
    drun $@
    break
    ;;
  commit)
    set_kube_context=0
    is_repo
    validate_cluster_env
    evaluate_secrets
    drun bin/pre-commit.sh
    git add . && git commit -m 'Manual commit'
    break
    ;;
  pull)
    set_kube_context=0
    is_repo
    validate_cluster_env
    evaluate_secrets
    git -C $ENV_DIR pull
    drun bin/crypt.sh dec
    break
    ;;
  *)
    show_usage
    [ "$1" != "" ] && echo "Error: Unknown command: $@"
    exit 1
    ;;
  esac
}

function verbose_env() {
  echo "env_dir=$env_dir"
  echo "stack_dir=$stack_dir"
  echo "helm_config=$helm_config"
  echo "otomi_image=$otomi_image"
  echo "set_kube_context=$set_kube_context"
  echo "K8S_CONTEXT=$K8S_CONTEXT"
}

function set_env_and_stack_dir() {
  local cwd=$(basename "$PWD")

  if [[ "$cwd" == 'otomi-stack' ]]; then
    [[ -z "$ENV_DIR" ]] && echo "Error: The ENV_DIR environment variable is not set" && exit 2
    stack_dir=$PWD
    env_dir=$ENV_DIR
    mount_stack_dir=1
  fi
  return 0
}

[[ -z "$command" ]] && echo "Error: Missing command argument" && show_usage && exit 2

set_env_and_stack_dir
set_env_ini
set_helm_config
execute $command $@
